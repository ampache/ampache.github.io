"use strict";(globalThis.webpackChunkampache_org_docs=globalThis.webpackChunkampache_org_docs||[]).push([[5159],{5670(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"docs/configuration/transcoding/transcoding","title":"Transcoding","description":"Transcoding","source":"@site/docs/docs/configuration/transcoding/transcoding.md","sourceDirName":"docs/configuration/transcoding","slug":"/docs/configuration/transcoding/","permalink":"/docs/configuration/transcoding/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Transcoding","metaTitle":"Transcoding","description":"Transcoding"},"sidebar":"api","previous":{"title":"Sample MPD config file","permalink":"/docs/configuration/localplay/Sample-Config-With-ALSA-and-Raspberry-PI"},"next":{"title":"Transcode Caching","permalink":"/docs/configuration/transcoding/transcode-caching"}}');var r=t(4848),a=t(8453);const o={title:"Transcoding",metaTitle:"Transcoding",description:"Transcoding"},i=void 0,c={},l=[{value:"Transcoding",id:"transcoding",level:2},{value:"Standard Transcoding",id:"standard-transcoding",level:2},{value:"Network Based Transcoding",id:"network-based-transcoding",level:2},{value:"Transcode Anyone outside 10.x Space",id:"transcode-anyone-outside-10x-space",level:3},{value:"Config Variables",id:"config-variables",level:4},{value:"ACL Interface Access for Clients",id:"acl-interface-access-for-clients",level:4},{value:"ACL Streaming Access for Clients",id:"acl-streaming-access-for-clients",level:4},{value:"ACL Local Network Definition",id:"acl-local-network-definition",level:4}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.RP)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"transcoding",children:"Transcoding"}),"\n",(0,r.jsxs)(n.p,{children:["Transcoding allows you to convert one type of file to another. Ampache supports on the fly transcoding of all file types based on user, IP address or available bandwidth. In order to transcode Ampache takes advantage of existing binary applications such as ",(0,r.jsx)(n.a,{href:"http://www.ffmpeg.org/",children:"ffmpeg"}),", ",(0,r.jsx)(n.a,{href:"http://lame.sourceforge.net/",children:"Lame"})," or ",(0,r.jsx)(n.a,{href:"http://mp3splt.sourceforge.net/mp3splt_page/home.php",children:"mp3splt"}),". In order for transcoding to work you must first install the supporting applications and ensure that they are executable by the webserver. If you have any trouble to get transcoding working you can also have a look at the ",(0,r.jsx)(n.a,{href:"/docs/help/troubleshooting/faq#unable-to-get-transcoding-working",children:"FAQ"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"WARNING:"})," Transcoding currently causes several issues documented in ",(0,r.jsx)(n.a,{href:"https://github.com/ampache/ampache/issues/1048",children:"#1048"})," which you should know about before enabling it. For that reason usability is quite limited with transcoding enabled."]}),"\n",(0,r.jsx)(n.h2,{id:"standard-transcoding",children:"Standard Transcoding"}),"\n",(0,r.jsx)(n.p,{children:"You will need to enable and configure transcoding in the config file before it will work."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:";######################################################\n; These are commands used to transcode non-streaming\n; formats to the target file type for streaming.\n; This can be useful in re-encoding file types that don't stream\n; very well, or if your player doesn't support some file types.\n;\n; 'Downsampling' will also use these commands.\n;\n; To state the bleeding obvious, any programs referenced in the downsample\n; commands must be installed, in the web server's search path (or referenced\n; by their full path), and executable by the web server.\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:"; Input type selection\n; TYPE is the extension. 'allowed' certifies that transcoding works properly for\n; this input format. 'required' further forbids the direct streaming of a format\n; (e.g. if you store everything in FLAC, but don't want to ever stream that.)\n; transcode_TYPE         = {allowed|required|false}\n; DEFAULT: false\n;transcode_m4a      = allowed\n;transcode_flac     = required\n;transcode_mp3      = allowed\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:"; Default output format\n; DEFAULT: none\n;encode_target = mp3\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:"; Override the default output format on a per-type basis\n; encode_target_TYPE = TYPE\n; DEFAULT: none\n;encode_target_flac = ogg\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:"; Command configuration. Substitutions will be made as follows:\n; %FILE% => filename\n; %SAMPLE% => target sample rate\n; You can do fancy things like VBR, but consider whether the consequences are\n; acceptable in your environment.\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:"; Master transcode command\n; transcode_cmd should be a single command that supports multiple file types,\n; such as ffmpeg or avconv. It's still possible to make a configuration that's\n; equivalent to the old default, but if you find that necessary you should be\n; clever enough to figure out how on your own.\n; DEFAULT: none\n;transcode_cmd = \"ffmpeg -i %FILE\"\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:'; Specific transcode commands\n; It shouldn\'t be necessary in most cases, but you can override the transcode\n; command for specific source formats.  It still needs to accept the\n; encoding arguments, so the easiest approach is to use your normal command as\n; a clearing-house.\n; transcode_cmd_TYPE = TRANSCODE_CMD\n;transcode_cmd_mid = "timidity -Or -o \u2013 %FILE% | ffmpeg -i pipe:0"\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:'; encode_args_TYPE = TRANSCODE_CMD_ARGS\n;encode_args_mp3 = "-vn -b:a %SAMPLE%K -c:a mp3 -f mp3 pipe:1"\n;encode_args_ogg = "-vn -b:a %SAMPLE%K -c:a vorbis -f ogg pipe:1"\n'})}),"\n",(0,r.jsx)(n.p,{children:"The arguments may need to be adjusted depending on the specific external program chosen and its age."}),"\n",(0,r.jsx)(n.h2,{id:"network-based-transcoding",children:"Network Based Transcoding"}),"\n",(0,r.jsxs)(n.p,{children:["You can also force transcoding based on the IP address of the user streaming. This allows you to automatically downsample and transcode music if the user is off of your local network. To enable this you first need to define a ",(0,r.jsx)(n.a,{href:"/docs/configuration/acl",children:"Local Network ACL"})," and then enable ",(0,r.jsx)(n.em,{children:"downsample_remote"})," in the ampache.cfg.php"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:"; Downsample Remote\n; If this is set to true and access control is on any users who are not\n; coming from a defined 'network' ACL will be automatically downsampled\n; regardless of their preferences.\n; DEFAULT: false\n;downsample_remote = \"false\"\n"})}),"\n",(0,r.jsx)(n.h3,{id:"transcode-anyone-outside-10x-space",children:"Transcode Anyone outside 10.x Space"}),"\n",(0,r.jsx)(n.p,{children:"The below example config would cause anyone whos IP is not 10.x.x.x to have their streams transcoded according to the transcode rules in the config file"}),"\n",(0,r.jsx)(n.h4,{id:"config-variables",children:"Config Variables"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-INI",children:'downsample_remote = "true"\naccess_control = "true"\n'})}),"\n",(0,r.jsx)(n.h4,{id:"acl-interface-access-for-clients",children:"ACL Interface Access for Clients"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"User"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Type"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Start Address"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"End Address"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Level"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"All"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"Interface"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"0.0.0.0"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"255.255.255.255"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"All"})]})})]}),"\n",(0,r.jsx)(n.p,{children:"This first ACL will let us continue to login after we've enabled the Access Control in the config file, next we need to allow streaming from our clients."}),"\n",(0,r.jsx)(n.h4,{id:"acl-streaming-access-for-clients",children:"ACL Streaming Access for Clients"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"User"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Type"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Start Address"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"End Address"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Level"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"All"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"Streaming"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"0.0.0.0"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"255.255.255.255"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"All"})]})})]}),"\n",(0,r.jsx)(n.p,{children:"Last we'll need to define what is our local network so that Ampache knows when it needs to transcode"}),"\n",(0,r.jsx)(n.h4,{id:"acl-local-network-definition",children:"ACL Local Network Definition"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"User"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Type"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Start Address"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"End Address"}),(0,r.jsx)(n.th,{style:{textAlign:"center"},children:"Level"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"All"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"Network"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"10.0.0.0"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"10.255.255.255"}),(0,r.jsx)(n.td,{style:{textAlign:"center"},children:"All"})]})})]}),"\n",(0,r.jsxs)(n.p,{children:["This will make is so that a client connecting from 192.168.0.32 would be considered Non-Local and would be forced to use any configured transcoding. A client coming from 10.0.32.12 would be considered local and would not be transcoded. ",(0,r.jsx)(n.strong,{children:"You can have as many network ACL definitions as you want."})]})]})}function h(e={}){const{wrapper:n}={...(0,a.RP)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{RP:()=>a,xA:()=>i});var s=t(6540);const r=s.createContext({});function a(e){const n=s.useContext(r);return s.useMemo(()=>"function"==typeof e?e(n):{...n,...e},[n,e])}const o={};function i({components:e,children:n,disableParentContext:t}){let i;return i=t?"function"==typeof e?e({}):e||o:a(e),s.createElement(r.Provider,{value:i},n)}}}]);